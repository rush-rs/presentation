% LTeX: language=de-DE
\section{Kompilierung zu low-level Architekturen}
\begin{frame}{Kompilierung zu low-level Architekturen}
	\pdfpcnote{
		- Zielmaschine und Betriebssystem spezifisch
		- Compiler generieren Assembly
	}

	\begin{itemize}
		\item<1-> Zielmaschine ist spezifisch
		\item<1-> Betriebssystem ist spezifisch
		\item<2-> Hier: die Compiler generieren Assembly
	\end{itemize}
\end{frame}

\begin{frame}{Abstraktionsgrad von Assembly}
	\begin{figure}[h]
		\begin{adjustbox}{max totalsize={\textwidth}{!},center}
			\begin{tikzpicture}[node distance=1cm, inner sep=3mm]
				\node (highlevel) [entity, fill=none] {High-level Sprachen\\(\emph{C}, \emph{Rust}, \emph{rush})};
				\node (asm) [entity, fill=mLightBrown!25, right=of highlevel, align=center] {Assembly\\Ebene};
				\draw [arrow] (highlevel) -- (asm);
				\node (machine) [entity, fill=none, right=of asm, align=center] {Machinensprache\\Ebene};
				\draw [arrow] (asm) -- (machine);
				\node (codegen) [entity, fill=none, right=of machine] {Betriebssystem-\\ und Hardwareebene};
				\draw [arrow] (machine) -- (codegen);
			\end{tikzpicture}
		\end{adjustbox}
	\end{figure}
\end{frame}

\begin{frame}{Stacklayouts}
	\pdfpcnote{
		@Silas \\
		\\
		- es gibt _Standards_ fuer die Struktur des Stacks \\
		- gezeigt sind die fuer RISC-V und x64 \\
		- nicht erzwungen \\
		- aber notwendig fuer interoperation mit bestehenden Bibliotheken \\
	}

	\begin{minipage}{0.45\textwidth}
		\hspace{-1.75cm}
		\begin{tikzpicture}[xscale=0.7, yscale=0.6]
			\scriptsize

			% manually set counter to allow stack frame including the start dots
			\setcounter{cellnb}{0}
			\startframe
			\addtocounter{cellnb}{-1}

			% copied code from `\stacktop{}` to not reset counter to in turn allow `\startframe` above this
			\draw[padding] (0,\value{cellnb})
			+(-2,.5) -- +(-2,-.5) -- +(2,-.5) -- +(2,.5);
			\draw (0,\value{cellnb}) node{...};

			\cell{$n$\textsuperscript{th} stack argument} \cellcom{\texttt{$8n$(fp)}}
			\cell[padding]{...}
			% custom draw instead of `\cellcom` for yshift
			\draw (2.4,\value{cellnb}) node[anchor=west, yshift=3.5pt] {\vdots};
			\cell{\nth{1} stack argument} \cellcom{\texttt{0(fp)}}
			\finishframe{previous}

			\startframe
			\cell{previous \qVerb{fp} value} \cellcom{\texttt{-8(fp)}}
			\cell{return address} \cellcom{\texttt{-16(fp)}}

			\padding{3}{\makecell{unspecified\\variable size}} \cellcom{\texttt{0(sp)}}
			% custom draws instead of `\cellcom` for yshift and padding cell offset
			\draw (2.4,\value{cellnb}+1) node[anchor=west, yshift=3.5pt] {\vdots};
			\draw (2.4,\value{cellnb}+2) node[anchor=west] {\texttt{-24(fp)}};
			\finishframe{current}
			\stackbottom[padding]

			\Large
			\draw (0,\value{cellnb}-1.5)  node(currentcell) {\riscv{}};
		\end{tikzpicture}
	\end{minipage}
	\hfill
	\begin{minipage}{0.45\textwidth}
		\hspace{-1.75cm}
		\begin{tikzpicture}[xscale=0.7, yscale=0.6]
			\scriptsize

			% manually set counter to allow stack frame including the start dots
			\setcounter{cellnb}{0}
			\startframe
			\addtocounter{cellnb}{-1}

			% copied code from `\stacktop{}` to not reset counter to in turn allow `\startframe` above this
			\draw[padding] (0,\value{cellnb})
			+(-2,.5) -- +(-2,-.5) -- +(2,-.5) -- +(2,.5);
			\draw (0,\value{cellnb}) node{...};

			\cell{$n$\textsuperscript{th} stack argument} \cellcom{\VerbCmd{\%rbp+}$(16+8n)$}
			\cell[padding]{...}
			% custom draw instead of `\cellcom` for yshift
			\draw (2.4,\value{cellnb}) node[anchor=west, yshift=3.5pt] {\vdots};
			\cell{\nth{1} stack argument} \cellcom{\VerbCmd{\%rbp+16}}
			\finishframe{previous}

			\cell{return address} \cellcom{\VerbCmd{\%rbp+8}}
			\cell{previous \qreg{rbp} value} \cellcom{\VerbCmd{\%rbp}}

			\startframe
			\padding{3}{\makecell{unspecified\\variable size}} \cellcom{\VerbCmd{\%rsp}}
			% custom draws instead of `\cellcom` for yshift and padding cell offset
			\draw (2.4,\value{cellnb}+1) node[anchor=west, yshift=3.5pt] {\vdots};
			\draw (2.4,\value{cellnb}+2) node[anchor=west] {\VerbCmd{\%rbp-8}};
			\finishframe{current}
			\stackbottom[padding]

			\Large
			\draw (0,\value{cellnb}-1.5)  node(currentcell) {x64};
		\end{tikzpicture}
	\end{minipage}
\end{frame}

\begin{frame}{Ãœbersetzung von Kontrollstrukturen zu linearen Programmfluss}
	\pdfpcnote{
		@Silas \\
		\\
		- Kontrollstrukturen muessen zu linearen Programmfluss ueberzsetzt werden \\
		- Beispiel: Struktur von if-else Verzweigungen in Assembly \\
		- Nutzung von Spruengen um basierend auf Bedingungen Teile des Programms zu ueberspringen \\
	}

	\centering
	\begin{tikzpicture}[every node/.style={minimum size=1.5ex}]
		\node(s)[vstack=8, rectangle split part align=left]{%
			\strut \emph{Bedingung}
			\nodepart{two}  \strut Springe zu \qVerb{.block_x} wenn die Bedingung nicht zutrifft
			\nodepart{three}\strut \emph{\enquote{if}-Block}
			\nodepart{four} \strut Springe zu \qVerb{.block_y}
			\nodepart{five} \strut \Verb{.block_x:}
			\nodepart{six}  \strut \emph{\enquote{else}-Block}
			\nodepart{seven}\strut \Verb{.block_y:}
			\nodepart{eight}\strut \dots
		};
		\draw[arrow] (s.two west) to [out=-150,in=150] (s.five west);
		\draw[arrow] (s.four west) to [out=-150,in=150] (s.seven west);
	\end{tikzpicture}
\end{frame}
